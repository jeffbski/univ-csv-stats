

Determine what the peak memory footprint is in like bytes?
 Maximum amount of memory used by the process during its execution in bytes. Generally represents the maximum memory allocation, which might include both physical memory and virtual memory
Can include memory that's been allocated but not necessarily actively used
May account for memory mapped files, shared libraries, and other memory allocations
Sometimes includes virtual memory allocations that aren't strictly physical RAM

 *Max RSS* - maximum resident set size - maximum amount of physical memory (RAM) that a process used during its execution. Measured in kilobytes on things like htop, but in time -l it is bytes.

Determine which time stats to use and is it in seconds?
 *real* is elapsed real time in seconds

Slide with companies using Rust, include some good stories behind some of the key ones.
For instance:
Amazon - firecracker VM
 - Werner Vogels CTO Keynote from last year encouraging use of Rust
Cloudflare - ?
1Password
Microsoft -
Google
Volvo?
Others from Rust in Production that I have listened to
Zed

Fantastic CLI tools in Rust

Incorporate the fact that Google Gemini 2.5 Pro and Claude are good at generating and understanding Rust, so AI augmented coding enables use of a safer more efficient language.

Plan on carefully reviewing the example code, showing some interesting characteristics of Rust code
- Options - No nulls
- Result - Required error handling
- ? for simplified check for error and return

Could show some other interesting Rust code from other snippets
- SQLx
- Axum
- async/await
- Rayon parallelization

Prepare to provide docs for continuing
- Where to learn rust
- Where to hear about Rust in production
- PyO3 release / publishing for multiple OS
- NAPI-rs release / publishing for multiple OS
- WASM publish
- WASI future


If I have time, create a rust app which will launch commands as processes and will track how long each takes. This will let us showcase async await, futures, further use of map, command launching and gathering output
- futures::try_join_all
- tokio::process::Command
- wrap with time_async fn using Instant::now() and start.elapsed()
